## 6-17-21
The amount of stuff I'm forgetting is getting ridiculous. I can spend days on a bug, only to forget what the problem was a few days after solving it. So now I will be logging what I am working on each day in this file.

Yesterday I managed to solve a GPU bug that prevented the bios from booting games. One of the DMA calls would appear to hammer the GPU with garbage data, causing the GPU to panic and halt the emulator. As it turns out, this garbage was texture data. The problem wasn't the data, but instead that the GPU wasn't ready to receive the data. Normally the program should initiate a CPU->VRAM transfer on the GPU, then send the pixel data. There was a transfer being initiated, but it just ended before the CPU was done sending data. 

The issue ended up being a problem with how transfer sizes are calculated. Because the data being transferred is a rectangular image, the CPU must give width and height information for the data about to be sent. These widths and heights are both measured in pixels. The total size is then obviously a simple width * height. Unfortunately, there is one complication here. The CPU is sending 32bit words, but the GPU stores pixels as 16bit halfwords. Two halfwords are AND'd together and sent in one word. The GPU then has to unpack the two pixels before it can store them. This is all well and nice, but what does it mean for our transfer size calculation? For each pixel sent, there's only half a transfer. So it follows that we need to halve the transfer size calculation. But that is not what I did. Instead, I made a dumb mistake and accidentally multiplied the transfer size by two. Now the transfer size is actually 4 times bigger than it should be. We definitely won't be missing texture data, but now future commands will be interpreted as texture data and therefore be missed. Let's say one of these commands is to start a new CPU->VRAM transfer. Instead of starting this new transfer, the GPU just continues with its old transfer, which is probably getting pretty close to finished by now. Once that original transfer ends, the GPU misinterprets the rest of the texture data as commands, causing the halt we saw earlier.

What I don't understand is why the emu worked at all with this bug. The bios was able to load the PlayStation logo textures just fine. The animated intro had no issues either. I can only assume this is one of those bugs that lined up just well enough to make everything look like it was working fine.